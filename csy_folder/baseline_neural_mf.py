# -*- coding: utf-8 -*-
"""baseline_neural_MF.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1w-SKjN6xaMCS4wCwZhWneyq8alC6_PcQ
"""

import pandas as pd
import numpy as np
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers
from pathlib import Path
import matplotlib.pyplot as plt

import glob
glob.glob("drive/My Drive/Colab Notebooks/melon_music_neg_sample_v2.csv")

df_meta = pd.read_csv('drive/My Drive/Colab Notebooks/Meta_v1.csv')

import json
with open('drive/My Drive/Colab Notebooks/new_idx_dict.json', 'r') as f:
  new_idx_dict = json.loads(f.read())

with open('drive/My Drive/Colab Notebooks/new_tag_id_dict.json', 'r') as f:
  new_tag_id_dict = json.loads(f.read())

tag2tag_id = new_tag_id_dict
tag_id2tag = {idx: tag for tag, idx in new_tag_id_dict.items() }

song_id2new_id = new_idx_dict
new_id2song_id = {idx: song_id for song_id, idx in new_idx_dict.items() }

# new_id2song_id

df = pd.read_csv('drive/My Drive/Colab Notebooks/melon_music_neg_sample_v2.csv')

df = df.sample(frac=1, random_state=42)

df.freq.value_counts().sort_index().plot(figsize=(16,9))

df.freq2.value_counts().sort_index().plot(figsize=(16,9))

x = df[["tag_id", "music_id"]].values
y = df["freq2"].values

x.shape, y.shape

train_indices = int(0.8 * x.shape[0])
x_train, x_val, y_train, y_val = (
    x[:train_indices],
    x[train_indices:],
    y[:train_indices],
    y[train_indices:],
)

x_train.shape

tag_count = 1382
music_count = 69888

EMBEDDING_SIZE = 50


class RecommenderNet(keras.Model):
    def __init__(self, num_tags, num_musics, embedding_size, **kwargs):
        super(RecommenderNet, self).__init__(**kwargs)
        self.num_tags = num_tags
        self.num_musics = num_musics
        self.embedding_size = embedding_size
        self.tag_embedding = layers.Embedding(
            num_tags,
            embedding_size,
            embeddings_initializer="he_normal",
            embeddings_regularizer=keras.regularizers.l2(1e-6),
        )
        self.tag_bias = layers.Embedding(num_tags, 1)
        self.music_embedding = layers.Embedding(
            num_musics,
            embedding_size,
            embeddings_initializer="he_normal",
            embeddings_regularizer=keras.regularizers.l2(1e-6),
        )
        self.music_bias = layers.Embedding(num_musics, 1)

    def call(self, inputs):
        tag_vector = self.tag_embedding(inputs[:, 0])
        tag_bias = self.tag_bias(inputs[:, 0])
        music_vector = self.music_embedding(inputs[:, 1])
        music_bias = self.music_bias(inputs[:, 1])
        dot_tag_music = tf.tensordot(tag_vector, music_vector, 2)
        x = dot_tag_music + tag_bias + music_bias
        return tf.nn.sigmoid(x)


model = RecommenderNet(tag_count, music_count, EMBEDDING_SIZE)
model.compile(
    loss=tf.keras.losses.BinaryCrossentropy(), 
    optimizer=keras.optimizers.Adam(lr=0.001)
)

history = model.fit(
    x=x_train,
    y=y_train,
    batch_size=512,
    epochs=1,
    verbose=1,
    validation_data=(x_val, y_val),
)

model.summary()

def get_top_music_by_tag(tag, model, k=10, df_meta=df_meta):
  if tag2tag_id.get(tag) == None: return "No Tag"

  target_tag_id = tag2tag_id.get(tag)
  inputs = np.vstack(([[target_tag_id] * music_count], [*range(music_count)])).T

  preds= model.predict(inputs).flatten()
  top_k =preds.argsort()[(-1*k):][::-1]
  
  recommended_music_ids = [
    int(new_id2song_id.get(x)) 
    for x in top_k
  ]
  top_song_names = df_meta[df_meta.id.isin(recommended_music_ids)][['artist_name_basket','song_name']].values
  return top_song_names



# Commented out IPython magic to ensure Python compatibility.
# %time get_top_music_by_tag("따뜻함", model, k=10)

# Commented out IPython magic to ensure Python compatibility.
# %time get_top_music_by_tag("해외일렉트로니카", model, k=10)

# Commented out IPython magic to ensure Python compatibility.
# %time get_top_music_by_tag("색다른", model, k=10)

































